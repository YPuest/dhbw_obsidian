#DigitalTechnik 

## Themen 
1. [[1. Codierung#Codierung Allgemein|Codierung Allgemein]]
2. [[1. Codierung#Arten von Codierung|Arten von Codierung]]
3. [[1. Codierung#Zeichencodierung|Zeichencodierung]]
4. [[1. Codierung#Zahlencodierung|Zahlencodierung]]
5. [[1. Codierung#Signalcodierung|Signalcodierung]]

---
## Codierung Allgemein

```ad-info
title:Definition
color: 255, 130, 178
Codierung ist die Darstellung von Information als Symbol oder Symbolfolge aus einem Alphabet. 

<font style="color:grey">Alphabet: eine endliche Menge von Symbolen</font>
```

```ad-tip
title:Hinweis
Die Ausgangsinfo kann analog oder digital sein, die Zielinfo ist immer digital.

Wenn die Ausgangsinfo digital ist, spricht man von einer "Umcodierung".
```

---

## Arten von Codierung
1. <font style="color:red">Zahlencodierung</font> <font style="color:grey">-> Zahlenwerte werden dargstellt</font>
2. <font style="color:red">Zeichencodierung</font> <font style="color:grey">-> Schriftzeichen werden dargestellt</font>
3. <font style="color:orange">Signalcodierung</font> <font style="color:grey">-> abstrakte Info wird als Signal oder Signalfolge dargestellt</font>
4. Anwendungscodierung <font style="color:grey">-> Info einer bestimmten Anwendung werden codiert</font>
5. Komprimierung <font style="color:grey">-> Umcodierung, bei welcher das Datenvolumen verringert werden soll </font>
6. Verschl√ºsselung <font style="color:grey">-> Umcodierung, bei welcher ohne Spezialinfos ("Schl√ºssel") die Ursprungsinfo nicht rekonstruiert werden kann</font>

```ad-info
title:Definition zu 3.
color:255, 130, 178
Ein *Signal* ist eine physisch messbare Gr√∂√üe.
```

```ad-example
title:Beispiele zu 4.
- Textcodierung (HTML, DOCX, ODT,...)
- Bildcodierung (PNG, JPEG, GIF, SVG,...)
- Videocodierung (MP4,...)
- Audiocodierung (MP3,...)
- Farbcodierung (RGB, CMYK, HSL,...)
```

---

## Zeichencodierung
```ad-abstract
title:Verschiedene Zeichencodierungen
- **ASCII** (‚âà 1970): Alphabet = {0, 1, 2, 3,..., 127}
	- max. 128 Schriftzeichen darstellbar
- **ISO-8859** (‚âà 1990): Alphabet = {0, 1, 2, 3,..., 255}
	- um "nationale Sonderzeichen" erweiterter ASCII-Zeichensatz
		- z.B. √§, √∂, √º, √Ñ, √ñ, √ú, √ü, √†, √Å √ß, ...
	- max. 256 Schriftzeichen darstellbar
	- verschiedene Varianten:
		- ISO-8859-1: westeurop√§isch (veraltet)
		- ISO-8859-5: kyrillisch
		- ISO-8859-7: griechisch
		- ISO-8859-15: westeurop√§isch (inkl. ‚Ç¨)
- **Unicode** (‚âà 2000): Anspruch, alle Schriftzeichen, aller aktuellen, ehemaligen und zuk√ºnftigen Schriftsprachen darstellen zu k√∂nnen
	- notwendig ist eine bestimnmte "*Transfercodierung*": #√ºberschl√§gigesRechnen 
		- *UTF-8*: Alphabet = {0,..., 255}
		- *UTF-16*: Alphabet = {0,...,65535}
		- *UTF-32*: Alphabet = {0,...,$2^{32}-1$}
	- Es muss jeweils mindestens ein "Fortsetzungssymbol" geben, welches anzeigt dass die Symbolfolge f√ºr das aktuelle Schriftzeichen noch nicht zu Ende ist
	- Die Wahl zwischen UTF-8/-16/-32 ist eine Frage der verwendeten Schriftzeichen und der Speicherplatz effizienz
```

---

## Zahlencodierung
### Abz√§hlsysteme
```ad-info
title:Definition
color:255, 130, 178
*Abz√§hlsysteme grunds√§tzlich:* dargestellter Zahlenwert wird bestimmt als Summe der dargestellten Symbolwerte
```

#### Fingerabz√§hlsystem
Alphabet = {**Finger** ‚òùÔ∏è}
Symbolwert (**Finger** ‚òùÔ∏è) = 1

*Beispiele:*
- 5 -> üñêÔ∏è
- 2 -> ‚úåÔ∏è

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:green">‚äï</font> extrem einfach, verst√§ndlich

<font style="color:red">‚äñ</font> extrem eingeschr√§nkt, Wertebeschr√§nkt (0-10)

<font style="color:grey">(bis auf weiteres nur nicht negative und ganze Zahlen)</font>

<font style="color:green">‚äï</font> extrem einfache Verfahren f√ºr Addition und Subtraktion
```

#### einfache Strichliste
Alphabet = { **|** }
Symbolwert ( **|** ) = 1

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:green">‚äï</font> unendlicher Wertebereich

<font style="color:red">‚äñ</font><font style="color:green">‚äï</font> Schreibwerkzeug wird ben√∂tigt

<font style="color:red">‚äñ</font> √ºbersichtlicher Wertebereich ist eingeschr√§nkt

<font style="color:green">‚äï‚äï</font><font style="color:red">‚äñ</font> Addition extrem einfach aber Subtraktion erfordert "L√∂schm√∂glichkeit"

<font style="color:red">‚äñ‚äñ</font><font style="color:green">‚äï</font> Multiplikation und Division mit einfachen Verfahren (mehrfache Addition bzw. Subtraktion) m√∂glich, aber deutlich h√∂herer Aufwand
```

*Beispiele:*
5: |||||
2: ||
7: ||||||| (oder auch ||||| ||)
10: |||||||||| (oder auch ||||| |||||)

##### erweiterte Strichliste
Jeder f√ºnfte Strich wird als Querstrich durch vier Striche gezogen
Alphabet = { **|**, **‚îº‚îº‚îº‚îº** }
Symbolwert ( **|** ) = 1
Symbolwert ( **‚îº‚îº‚îº‚îº** ) = 5

*Regel:* Symbole m√ºssen sortiert nach Wertigkeit notiert werden.

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:red">‚äñ</font> √ºbersichtlicher Wertebereich bis 50

<font style="color:red">‚äñ</font> Addition und Subtraktion erfordern zus√§tzliche Neusortierung und ggf. Zusammenfassen bzw. Aufl√∂sung von Symbolen
```

#### r√∂misches Zahlensystem
Alphabet = {**I**, **V**, **X**, **L**, **C**, **D**, **M**}
Symbolwert ( **|** ) = 1
Symbolwert ( **V** ) = 5
Symbolwert ( **X** ) = 10
Symbolwert ( **L** ) = 50
Symbolwert ( **C** ) = 100
Symbolwert ( **D** ) = 500
Symbolwert ( **M** ) = 1000

*Beispiele:*
4 $\neq$ $\mathrm{IIII}$
4 = $\mathrm{IV}$

*Sonderregel:* niedrigwertiges Symbol vor h√∂herwertigem Symbol ist manchmal erlaubt, aber der niedere Wert wird dann vom h√∂heren Wert abgezogen und nicht aufsummiert.
Nur maximal drei gleiche Symbole nebeneinander erlaubt <font style="color:grey">(daraus folgt auch einer der Nachteile des Systems)</font>.

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:red">‚äñ</font> nur endlicher Wertebereich bis etwa 4000

<font style="color:red">‚äñ</font> Rechnen ist ein Alptraum
```

### Stellenwertsysteme (SWS)

#### Dezimalsystem
Alphabet = {**0**, **1**, **2**, **3**, **4**, **5**, **6**, **7**, **8**, **9**}
Symbole hei√üen "Ziffern"
Ziffernwert (**0**) = 0
.
.
.
Ziffernwert (**9**) = 9

$n$-stellige Zahl ist eine Folge von Ziffern
$Z_{n-1}Z_{n-2}Z_{n-3}\dots Z_2Z_1Z_0$

##### Werteformel
Wert ($Z_{n-1}\dots Z_0$) = $$\sum_{i=0}^{n-1}\vert Z_{i} \cdot 10^i$$
$Z_i$ = Ziffernwert
$10^i$ = Stellenwert

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:red">‚äñ</font><font style="color:green">‚äï</font> etwas komplexer, aber noch etwas Einarbeitungszeit gut verst√§ndlich und einfach verwendbar

<font style="color:green">‚äï</font> undendlicher Wertebereich

<font style="color:red">‚äñ</font><font style="color:green">‚äï</font> sehr gro√üer √ºbersichtlicher Wertebereich (bis $10^{10} = 10 Mrd.$)

<font style="color:green">‚äï</font> erstmals explizite Darstellung der "0" m√∂glich

<font style="color:red">‚äñ</font><font style="color:green">‚äï</font> Verfahren f√ºr alle Grundrechenarten mit gewisser Komplexit√§t, aber m√§√üigem Aufwand verf√ºgbar
```

#### SWS zur Basis b
$b \in \mathbb{N}\backslash\{1\} \qquad (b \gt 1 \text{ oder } b \ge 2)$
Ziffernmenge enth√§lt genau $b$ verschiedene Ziffern, die kleinste Ziffer hat den Wert $0$, die gr√∂√üte Ziffer hat den Wert $(b-1)$

##### Werteformel
Wert $(Z_{n-1}Z_{n-2}\dots Z_2Z_1Z_{0}) =$ $$\sum\limits_{i=0}^{n-1} \vert Z_i\vert \cdot b^i$$
```ad-tip
title:Hinweis
SWS zur Basis $b = 1$ ist *keine* Strichliste; der einzig darstellbare Wert ist $0$, da $0$ auch die einzige Ziffer ist -> SWS zur Basis 1 macht keinen Sinn
```

```ad-question
title:Vor- und Nachteile
color: 182, 106, 247
<font style="color:green">‚äï</font> √ºbersichtlicher Wertebereich bis etwa $b^{10}$ (exponentielle und nicht nur lineare Abh√§ngigkeit von $b$)

**Hinweis:** Bei gr√∂√üeren Basen leidet die √úbersichtlichkeit, aber an der Anzahl 
```

#### g√§ngige Basen
$b = 10$: Dezimalsystem -> von Menschen verwendet
$b = 2$: Bin√§r/Dualsystem -> von Computern verwendet
$b = 16$: Hexadezimalsystem -> f√ºr kompakte und Computer-nahe Darstellung von <br>                                                     Zahlen mit einfacher und direkter<br>                                                     Umrechnungsm√∂glichkeit ins Bin√§rsystem
$b = 8$: Oktalsystem -> <font style="color:grey">folgt in K√ºrze</font>

#### Umrechnung zwischen verschiedenen Basen

<font style="color:MediumAquaMarine">a) Umrechnung von Basis </font>$b \neq 10$ <font style="color:MediumAquaMarine">nach Basis</font> $10$
-> **Werteformel** $$\sum\limits_{i=0}^{n-1} \vert Z_{i} \vert \cdot b^i$$
<font style="color:MediumAquaMarine">b) Umrechnung von Basis nach Basis </font>$b_{2} \neq 10$
1. umgekehrte Werteformel
2. Ganzzahldivision und Restbildung
	die notierten Reste ergeben die Ziffernfolge zur Basis $b_2$

*Beispiel:*
$62_{10} = ?_2$
$62 : 2 = 31 \; R\; 0 \qquad 0 = Z_0$
$31 : 2 = 15 \; R \; 1 \qquad 1 = Z_1$
$15 : 2 = 7 \; R \; 1 \qquad 1 = Z_2$
$7 : 2 = 3 \; R \; 1 \qquad 1 = Z_3$
$3 : 2 = 1 \; R \; 1 \qquad 1 = Z_4$
$1 : 2 = 0 \; R \; 1 \qquad 1 = Z_5$
$= 111110_2$

$\begin{align}111110_{2} &= 0 \cdot 2^{0} + 1 \cdot 2^{1} +  1 \cdot 2^{2} +  1 \cdot 2^{3} + 1 \cdot 2^{4} + 1 \cdot 2^{5} \\ &= 0 \cdot 1 + 1 \cdot 2 + 1 \cdot 4 + 1 \cdot 8 + 1 \cdot 16 + 1 \cdot 32 \\ &= 0 + 2 + 4 + 8 + 16 + 32 \\ &= 63\end{align}$


$62_{10} = ?_3$
$62 : 3 = 20 \; R\; 2 \qquad 2 = Z_0$
$20 : 3 = 6 \; R \; 2 \qquad 2 = Z_1$
$6 : 3 = 2 \; R \; 0 \qquad 0 = Z_2$
$2 : 3 = 0 \; R \; 2 \qquad 1 = Z_3$
$3 : 2 = 1 \; R \; 1 \qquad 1 = Z_4$
$1 : 2 = 0 \; R \; 1 \qquad 1 = Z_5$
$= 2022_3$

$\begin{align}2022_{3} &= 2 \cdot 3^{0} + 2 \cdot 3^{1} + 0 \cdot 3^{2} + 2 \cdot 3^{3} \\ &= 2 \cdot 1 + 2 \cdot 3 +  0 \cdot 0 + 2 \cdot 27 \\ &= 2 + 6 + 0 + 54 \\ &= 62_{10}\end{align}$
<font style="color:MediumAquaMarine">c) Umrechnung von Basis </font>$b_{1} \neq 10$
*allgemein:* Umrechnung in zwei Teilschritten:
	von $b_1$ nach $b_z = 10$
	und von $b_z = 10$ nach $b_2$
(reintheoretisch w√§re das auch per Ganzzahldivision durch $b_2$ direkt machbar, aber die Rechnung m√ºsste zur Basis $b_1$ durchgef√ºhrt werden)
*direkte Umrechnung* ist m√∂glich, falls $b_1^k = b_2$, dann k√∂nnte $k$ Ziffern zur Basis $b_1$ in eine Ziffer zur Basis $b_2$ "umgerechnet" werden (am besten in einer Tabelle)
	*Beispiel:*
	Von $b_{1} = 2$ nach $b_{2} = 16$ (wird umgerechnet):
	$2^{4} = 16$

*direkte Umrechnung* ist auch dann m√∂glich wenn $b_1^k = b_2^m$, dann kann eine Folge von $k$ Zifferns zur Basis $b_1$ direkt in eine Folge von $m$ Ziffern zur Basis $b_2$ umgerechnet werden
	*Beispiel:*
	$8^{k} = 16^m$
	$(2^3)^k = (2^4)^m$
	$2^{3k} = 2^{4m}$
	$3k = 4m$
	-> $k = 4 \text{ und } m = 3$
	$8^{4} = 16^3$
	Problem: Umrechnungstabelle hat $8^{4} = 16^{3} = 2^{12} = 4096$

*Beispiel:*

| Wert | Hexziffern | 4-Bin√§rziffernfolge |
| ---- | ---------- | ------------------- |
| 0    | 0          | 0000                |
| 1    | 1          | 0001                |
| 2    | 2          | 0010                |
| 3    | 3          | 0011                |
| 4    | 4          | 0100                |
| 5    | 5          | 0101                |
| 6    | 6          | 0110                |
| 7    | 7          | 0111                |
| 8    | 8          | 1000                |
| 9    | 9          | 1001                |
| 10   | A          | 1010                |
| 11   | B          | 1011                |
| 12   | C          | 1100                |
| 13   | D          | 1101                |
| 14   | E          | 1110                |
| 15   | F          | 1111                |

$AFFE_{16} = 1010\;1111\;1111\;1110_2$
$10\;1111\;1100_2 = 2FC_{16}$

---

| Hexadezimal                                                                          | Oktal                                                                         |
| ------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------- |
| <font style="color:green">‚äï</font> kompakte Darstellung                              | <font style="color:green">‚äï</font> nur Verwendung von √ºblichen Ziffersymbolen |
| <font style="color:green">‚äï</font> 1 Byte ist mit genau zwei Hex-Ziffern darstellbar |                                                                               |
| heute √ºblicherweise verwendet                                                        | fr√ºher h√§ufiger verwendet                                                                              |

| Wert | Oktalziffern | 3-Bin√§rziffernfolge |
| ---- | ------------ | ------------------- |
| 0    | 0            | 000                 |
| 1    | 1            | 001                 |
| 2    | 2            | 010                 |
| 3    | 3            | 011                 |
| 4    | 4            | 100                 |
| 5    | 5            | 101                 |
| 6    | 6            | 110                 |
| 7    | 7            | 111                 |

$AFFE_{16} = 1010\;1111\;1111\;1110_2 = {\color{#808080}00}1\;010\;111\;111\;111\;110_2 = 127776_{8}$

### Aufhebung der Einschr√§nkungen:
#### Darstellung von (auch) negativen Zahlen
<font style="color:MediumAquaMarine">a) Vorzeichen und Betrag</font>
notwendig ist (mindestens) ein weiteres Symbol im Alphabet f√ºr das "Vorzeichen":
Minus: **-**
<font style="color:grey">optional Plus: <b>+</b></font>

<font style="color:red">‚äñ Nachteile:</font>
- zwei unterschiedliche Verfahren f√ºr die "Addition" von positiven und negativen Zahlen notwendig (Addition einer negativen Zahl m√ºsste als Subtraktion ausgef√ºhrt werden)
- nicht eindeutige Darstellung der Null (+0) und (-0)

<font style="color:MediumAquaMarine">b) Einerkomplement</font> <font style="color:grey">(nur noch Bin√§r)</font>
Festlegen der Stellenzahl so, dass sie mindestens "1" gr√∂√üer ist als notwendig f√ºr den gr√∂√üten Betrag im gesammten Rechenweg

Invertieren jeder Ziffer in der Ziffernfolge:
	$0 \to 1$ und $1 \to 0$
*Beispiel:*
$5_{10} = 0101_{2} \stackrel{inv}{\to} 1010 = -5$

$42_{10} = 101010_{2} = 0010\;1010 \stackrel{inv}{\to} 1101\;0101 = -42$
$13_{10} = 1101_{2} = 0000\;1101 \stackrel{inv}{\to} 1111\;0010 = -13$

$\begin{align}&-42: 1101\;0101\\&+13: 0000\;1101\\\hline&\qquad\quad1110\;0010 = -29{\color{grey}\text{ negativ}}\end{align}$ 

$1110\;0010 \stackrel{inv}{\to} 0001\;1101 = 29$

$\begin{align}&+42: 0010\;1010\\&-13: 1111\;0010\\\hline&\qquad\quad0001\;1100 = 28{\color{grey}\text{ positiv}}\end{align}$
Ergebnis liegt (haarscharf) um 1 daneben, ist also falsch. Die h√§lfte aller Rechnungen im Einerkomplement ist richtig, die andere falsch.

```ad-tip
title:negierte Null
$0 = 0000\;0000 \stackrel{inv}{\to} 1111\;1111 =$ "$-0$"
‚Üí keine eindeutige Darstellung der Null
```

```ad-tip
title:Wertebereich mit 8bit
gr√∂√üte Zahl: $0111\;1111 = 1 + 2 + 4 + 8 + 16 + 32 + 64 = 127$

kleinste Zahl: $1000\;0000 \stackrel{inv}{\to} 0111\;1111 = 127 \implies 1000\;0000 = -127$

- Wertebereich von $-127$ bis $127$ mit 8bit Einerkomplement darstellbar.
- insgesamt "nur" 255 Zahlendarstellbar (statt 256, wie mit 8bit eigentlich m√∂glich sein sollten)
```

‚Üí somit ergeben sich 3 Nachteile des 1er-Komplements

<font style="color:MediumAquaMarine">c) Zweierkomplement</font>
Bildung wie 1er-Komplement, d.h. Stellenanzahl festlegen, alle Ziffern "invertieren", dann zus√§tzlich "+1" addieren.

$42: 101010 = 0010\;1010 \stackrel{inv}{\to} 1101\;0101 \stackrel{+1}{\to} 1101\;0110$
$13: 1101 = 0000\;1101 \stackrel{inv}{\to} 1111\;0010 \stackrel{+1}{\to} 1111\;0011$

$\begin{align}&-42: 1101\;0110\\&+13: 0000\;1101\\\hline&\qquad\quad1110\;0011{\color{grey}\text{ negativ}}  = -29\end{align}$

$1110\;0011 \stackrel{inv}{\to} 0001\;1100 \stackrel{+1}{\to} 0001\;1101 = 1 + 4 + 8 + 16 = 29$

$\begin{align}&+42:\; 0010\;1010\\&-13:\; 1111\;0011\\&\text{ign.‚Üí}{\color{IndianRed}1\;}{\color{grey}1100\;010}\\\hline&\qquad\quad0001\;1101 = 29{\color{grey}\text{ positiv}}\end{align}$

```ad-warning
title:Wichtig
Die f√ºhrende $0$ gibt an, dass es sich um eine positive Zahl handelt. Ist die f√ºhrende Ziffer eine $1$, so ist die Zahl negativ.
```

```ad-tip
title:Darstellung der 0
$0000\;0000 \stackrel{inv}{\to} 1111\;1111 \stackrel{+1}{\to} 0000\;0000 = 0$
- eine Darstellung der 0
```

```ad-tip
title:Wertebereich mit 8bit
gr√∂√üte Zahl: $0111\;1111 = 127$

kleinste Zahl: $1000\;0000 \stackrel{inv}{\to} 0111\;1111 \stackrel{+1}{\to} 1000\;0000$ (<font style="color:indianRed">nicht negativ, da Betrag einer Zahl!</font>) $= 128 \implies -128$

- Wertebereich geht von -128 bis +127
- insgesamt 256 verschiedene Werte
- <font style="color:red">‚äñ</font> unsymmetrischer Wertebereich, d.h. es gibt mehr negative als positive darstellbare Zahlen
```

#### Darstellung (auch) nicht-ganzer Zahlen
<font style="color:grey">(vorl√§ufig wieder nur nicht-negative Zahlen)</font>

<font style="color:MediumAquaMarine">a) Br√ºche</font><font style="color:grey"> (d.h. Darstellung mit Z√§hler und Nenner, dazwischen ein Bruchstrich)</font>

z.B. $\frac{1}{2}, \frac{1}{4}, \frac{1}{10}, \frac{3}{8}$

$1 = \frac{1}{1} = \frac{2}{2} = \frac{3}{3} = \frac{4}{4} = \dots$

‚Üí f√ºr jede Zahl gibt es unendlich viele Darstellungen als Bruch
Abhile: maximales K√ºrzen

Darstellung als Bruch ist im Computer un√ºblich. 
Ausnahme: Mathematikprogramme zum L√∂sen von Gleichungssystemen (z.B. Maple, GeoGebra, WolframAlpha)

<font style="color:MediumAquaMarine">b) Festkommazahl</font>
notwendig ist (mindestens) ein weiteres Symbol im Alphabet:
Komma: **,**

‚Üí Das Komma darf nur genau einmal verwendet werden, davor gibt es $n$ Vor- und $m$ Nachkommastellen $Z_{n-1}Z_{n-2}\dots Z_{2}Z_{1}Z_{0}{\color{red},} Z_{-1}Z_{-2}\dots Z_{-m+1}Z_{-m}$
Das geht mit unteschiedlichen Basen $b \in \mathbb{N}\backslash\{1\}$

*Kommazahlen zwischen verschiedenen Basen umrechnen:*
z.B. $1101,0011_{2} = ?_{10}$
Werteformel: $\sum\limits_{i=0}^{n-1}\vert Z_{i} \vert \cdot b^{i}+ \sum\limits_{j=1}^{m}\vert Z_{i}\vert \cdot b^{-1} = \sum\limits_{i=-m}^{n-1}\vert Z_{i}\vert \cdot b^{i}$

$\begin{align}1101,0011_{2} &= 1\cdot 2^{0} + 0 \cdot 2^{1} + 0 \cdot 2^{2} + 1 \cdot 2^{3} + 0 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} \\ &= 1 + 4 + 8 + \frac{1}{8} + \frac{1}{16} \\ &= 13 + 0,125 + 0,0625 \\ &= 13,1875_{10} \end{align}$
*Umrechnung von Basis 10 nach Basis $b \neq 10$:*
getrennte Behandlung von Vor- und Nachkommaanteil:
- Vorkommateil umwandeln, wie bekannt, also Ganzzahldivision mit Rest oder umgekehrte Werteformel.
- Nachkommateil entweder √ºber umgekehrte Werteformel (teilweise schwierig handhabbar) oder √ºber Multiplikation mit Zielbasis und Aufteilung in Vor- und Nachkommaanteil; Vorkommaanteil ist die n√§chste Nachkommastelle, mit dem Nachkommateil muss weitergerechnet werden.

$13,1875_{10} = 1101,0011{\color{grey}0}_{2}$
$0,1875 \cdot 2 = 0,375 \to Z_{-1}= 0$
$0,375 \cdot 2 = 0,75 \to Z_{-2}=0$
$0,75 \cdot 2 = 1,5 \to Z_{-3}= 1$
$0,5 \cdot 2 = 1,0 \to Z_{-4}=1$
${\color{grey}0,0 \cdot 2 = 0,0 \to Z_{-5} = 0}$
${\color{grey}\dots}$

<font style="color:MediumAquaMarine">c) Gleitkommazahl (GKZ)</font>
GKZ besteht aus Mantisse und Exponent.
$$\text{Wert(GKZ)} = \text{Mantisse } \cdot b^{\text{Exponent}}$$
Die Mantisse ist eine (Fest-)Kommazahl und gibt die Ziffernfolge der Zahl an.
Der Exponent ist eine ganze Zahl (positiv und negativ m√∂glich) und gibt die Verschiebung des Kommas (Anzahl der Stellen) bei der Mantise an (Vorzeichen des Exponenten steht dabei f√ºr die Richtung der Verschiebung nach rechts oder links).

z.B. $1 = {\color{LightSalmon}1,0 \cdot 10^{0}}= {\color{GoldenRod}0,1 \cdot 10^{1}}= 10,0 \cdot 10^{-1} = \dots$
‚Üí f√ºr jede Zahl gibt es unendlich viele Darstellungen als GKZ
Abhilfe: normierte Darstellung, aber: es gibt zwei <font style="color:IndianRed">Varianten</font>
<font style="color:LightSalmon">a) nur eine Vorkommastelle, diese ist</font> ${\color{LightSalmon}\neq 0}$
<font style="color:GoldenRod">b) Vorkommaanteil ist </font>${\color{GoldenRod}= 0}$<font style="color:GoldenRod">, die erste Nachkommastelle ist</font> ${\color{GoldenRod}\neq 0}$

Die g√§ngige Variante ist Variante <font style="color:LightSalmon">a</font>
Problem: F√ºr die "0" gibt es keine normierte Darstellung
Abhilfe: F√ºr die "normierte 0" gibt es eine reservierte Bitfolge (nur "0")

```ad-tip
title:Hinweis
Die Basen f√ºr die Darstellung der Mantisse und mit welcher der Exponent potenziert wird, m√ºssen die gleichen sein, da der Exponent die Kommaverschiebung der Mantisse vorgeben soll.

Im Computer wird die Basis $b = 2$ verwendet.
```

```ad-tip
title:Gr√∂√üenvergleich von zwei GKZ
1. Vergleich der Exponenten ‚Üí gr√∂√üerer Exponent geh√∂rt zur gr√∂√üeren Zahl
2. bei gleichem Exponent ‚Üí erst Gr√∂√üenvergleich der Mantissen
```

*Beispiel zum Gr√∂√üenvergleich:*
$42 = 00{\color{red}1}0\;1010 \stackrel{inv}{\to} 1101\;0101 \stackrel{+1}{\to}11{\color{red}0}1\;0110 = -42$
$13 = 00{\color{red}0}0\;1101 \stackrel{inv}{\to} 1111\;0010 \stackrel{+1}{\to}11{\color{red}1}1\;0011=-13$
‚Üí Pr√ºfen von links nach rechts, erste unterschiedliche Ziffer: $1$ geh√∂rt zur gr√∂√üeren Zahl

$+42 = {\color{red}0}010\;1010$
$-13 = {\color{red}1}111\;0011$
‚Üí Problem: bei unteschiedlichem Vorzeichen geh√∂rt die "0" zur gr√∂√üeren Zahl
- Fallunterscheidung w√§re n√∂tig
- *Keine 2er-Komplement-Darstellung beim Exponent √ºblich!*
Stattdessen: "Bias-Darstellung"
$\text{Exp}_{\text{gesp}}=\text{Exp}_{\text{real}}+\text{Bias}$
$\text{Exp}_{\text{real}}=\text{Exp}_{\text{gesp}}-\text{Bias}$
z.B. bei 8bit ‚Üí Bias = 127 ‚Üí Wertebereich f√ºr $\text{Exp}_{\text{real}}$ von $-127$ bis $+128$ darstellbar

**Normierung (Variante a):** eine Vorkommastelle $\neq 0$
im Bin√§rsystem ist diese also immer "1"
‚Üí diese "1" braucht man nicht expliziet zu speichern, sondern nutzt das bit besser f√ºr eine weitere Nachkommastelle.
‚Üí Hidden-Bit-Darstellung (√ºblicherweise verwendet und empfohlen)
Problem: Bei der "0" darf es kein Hidden-Bit geben ‚Üí beim f√ºr "0" definierten Bitmuster gibt es kein Hidden-Bit

#### Darstellung (auch) nicht-ganzer, negativer Zahlen
eine negative Mantisse macht auch die Gleitkommazahl negativ.

**Addition von 2 GKZ:**
- erst muss bei einer GKZ das Komma so verschoben werden, dass sie denselben Exponenten wie die andere GKZ hat (Aufhebung der Normierungsbedingung f√ºr eine GKZ) danach Addition der Mantisse.
	z.B. $$\begin{align}1,01101 \cdot &2^{3}= 0,0101101 \cdot 2^{5}\\ 1,01101 \cdot &2^{5}\end{align}$$
	$$01,01101 \stackrel{inv}{\to} 10,10010 \stackrel{inv}{+1} 10,10011 \cdot 2^{3}$$
	‚Üí zur Fallunterscheidung m√ºsste jetzt eine f√ºhrende "1" vorne drangestellt werden
	‚Üí Fallunterscheidung wird eingespart
##### negative Mantisse?
- kein 2er-Komplement
- Vorzeichen und Betrag als Speicherformat (nur f√ºr die Rechnung wird "kurzzeitig" das 2er-Komplement verwendet)

### IEEE 754
| **Genauigkeit**  | **Speichermenge** \[bit\] | **Vorzeichen** \[bit\] | **Mantisse** \[bit\] | **Exponent** \[bit\] | <i>empfohlener</i> **Bias** |
| ---------------- | ------------------------- | ---------------------- | -------------------- | -------------------- | -------------------- |
| **half**         | 16                        | 1                      | 10                   | 5                    | 15                   |
| **float/single** | 32                        | 1                      | 23                   | 8                    | 127                  |
| **double**       | 64                        | 1                      | 52                   | 11                   | 1023                 |

*au√üerdem:*
- Hidden-Bit-Darstellung empfohlen
- Normierung mit einer Vorkommastelle $\neq$ 0 empfohlen
- gespeichert wird in der Reihenfolge: Vorzeichen - Exponent - Mantisse

#### reservierte Bitmuster
- alle bit "0": Zahlenwert 0 (kein Hidden-Bit)
- alle Exponentenbit "0": kein Hidden-Bit, keine normierte Darstellung
	$\text{Exp}_{\text{real}}$ = $1 - \text{Bias}$ (um L√ºcke zwischen kleinster normierter und gr√∂√üter nicht-normierter Zahl zu verhindern)
- alle Exponentenbita "1" 
	- und alle Mantissenbits "0": Zahl liegt au√üerhabl des darstellbaren Wertebereichs also "$\pm\infty$"
	- und Mantisse $\neq$ 0: Zahl ist "NaN" (z.B. beim Teilen durch 0 oder Ziehen der Wurzel von -1)

#### Wertebereich von Gleitkommazahlen ‚Äî <i>am Beispiel von "half"</i>
zum Vergleich:
- 16 bit nicht-negative ganze Zahlen: $0 \text{ bis } 65535\,(= 2^{16}-1)$
- 16 bit 2er-Komplement: $-32768 \text{ bis } +32767$
- 16 bit GKZ "half":
	- gr√∂√üte Zahl (<font style="color:grey">siehe</font> [[1. Codierung#half (gr√∂√üte Zahl)|Tabelle]]): 
		- Wert (gr√∂√üte Zahl): $(2-2^{10})\cdot2^{15}=2^{16}-2^{5}=65536-32=65504$
	- kleinste Zahl (<font style="color:grey">siehe</font> [[1. Codierung#half (kleinste Zahl)|Tabelle]]): 
		- Wert (kleinste Zahl): $-65504$

###### half (gr√∂√üte Zahl)

| 0                              | 11110                                                                                                     | <font style="color:PaleTurquoise">[1,]</font>1111111111        |
| ------------------------------ | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| <b>Vorzeichen</b> <br> positiv | <b>Exponent (gespeichert)</b><br> Exp (gesp) = 30 <br> Exponent (real) = Exp(gesp) - Bias = 30 - 15 = 15 | <b>Mantisse</b><br>Mantisse = $2 - 2^{10} = 2- \frac{1}{1024}$ |

###### half (kleinste Zahl)

| 1                              | 11110                                                                                                     | <font style="color:PaleTurquoise">[1,]</font>1111111111        |
| ------------------------------ | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| <b>Vorzeichen</b> <br> negativ | <b>Exponent (gespeichert)</b><br> Exp (gesp) = 30 <br> Exponent (real) = Exp(gesp) - Bias = 30 - 15 = 15 | <b>Mantisse</b><br>Mantisse = $2 - 2^{10} = 2- \frac{1}{1024}$ |

<font style="color:PaleTurquoise">Hidden-Bit</font>

##### kleinste positive Zahl <i>(d.h. kleinster Betrag)</i>
<font style="color:MediumAquaMarine">a) normierte Darstellung</font>

| 0   | 00001                                                          | <font style="color:PaleTurquoise">[1,]</font>0000000000 |
| --- | -------------------------------------------------------------- | ---------- |
| VZ  | Exp                                                            | Mantisse   |
|     | $\text{Exp}_\text{gesp} = 1$<br>$\text{Exp}_\text{real} = 1-15=-14$ | $\text{Mantisse} = 1$           |

Wert (Zahl) = $1 \cdot 2^{-14}= \cfrac{1}{16384}$

<font style="color:MediumAquaMarine">b) nicht-normierte Darstellung</font>

| 0   | 00000                                                          | <font style="color:CornflowerBlue">[0,]</font>0000000001 |
| --- | -------------------------------------------------------------- | ------------------------------------------------------- |
| VZ  | Exp                                                            | Mantisse                                                |
|     | $\text{Exp}_\text{gesp} = 1$<br>$\text{Exp}_\text{real} = 1-15=-14$ | $\text{Mantisse} = 2^{-10}$                                   |

Wert (Zahl) = $2^{-10}\cdot2^{-14}=2^{-24}\approx \cfrac{1}{16\text{ Mio}}$

<font style="color:CornflowerBlue"> kein Hidden-Bit</font>

#### Umrechnung einer Dezimalkommazahl in eine Gleitkommazahl zur Basis 2
z.B. $-4,2 \cdot 10^{-1}$
1. Entfernen des Vorzeichens und merken f√ºr sp√§ter: $4,2\cdot10^{-1}$
2. Umwandeln in eine Kommazahl ohne Exponent: $0,42$
3. Umwandeln der Zahl (zur Basis $10$) in die Zielbasis nach bekannten Verfahren, bis die Anzahl relevanter Stellen bei der Mantisse (d.h. die entsprechende Stellenzahl nach der ersten "1") erreicht ist
$$\begin{align}0,42_{10}&=0,0{\color{PaleTurquoise}1}1010111000_{2}=1,10101110000\cdot2^{-2}\\\\0,42\cdot2&=0,84\\0,84\cdot2&=1,68\\0,68\cdot2&=1,36\\0,36\cdot2&=0,72\\0,72\cdot2&=1,44\\0,44\cdot2&=0,88\\0,88\cdot2&=1,76\\0,76\cdot2&=1,52\\0,52\cdot2&=1,04\\0,04\cdot2&=0,08\\\vdots\end{align}$$
4. Bestimmen des Exponenten durch verschieben des Kommas bei der Mantisse, um den Exponenten $\text{Exp}_\text{real}$ zu bestimmen
$$\begin{align}&0,0{\color{PaleTurquoise}1}1010111000_{2}=1,10101110000\cdot2^{-2}\\&\text{Exp}_\text{real} = -2\end{align}$$
5. $\text{Exp}_\text{gesp} = \text{Exp}_\text{real}+\text{Bias}$ $$\text{Exp}_\text{gesp}=-2+15=13$$
6. $\text{Exp}_\text{gesp}$ in Bin√§rsystem umrechnen und mit vorgegebener Stellenzahl darstellen$$\text{Exp}_\text{gesp}=-2+15=13=8+4+1=01101$$
7. Bitmuster in vorgegebner Reihenfolge notieren $\text{Vorzeichen} - \text{Exp}_\text{gesp} - \text{Mantisse}$
$$\begin{align}-4,2 \cdot 10^{-1} = {\color{MediumAquaMarine} 1} \; {\color{GoldenRod} 01101} \; {\color{#6495ED} 1010111000}\\{\color{MediumAquaMarine} Vorzeichen}, \; {\color{GoldenRod} Exponent}, \; {\color{#6495ED} Mantisse}\end{align}$$
Zahlencodierung l√§sst sich untescheiden in
- Wertecodierung:
	Der Wert an sich wird umgerechnet in die Zieldarstellung
- Zifferncodierung:
	Die bereits in einem Stellenwertsystem codierte Zahl wird Ziffer f√ºr Ziffer in die andere Darstellung gebracht

<i>Alle Zahlencodierungen waren bisher Wertecodierung</i>
Ausnahme: direkte Umrechnung zwischen zwei verschiedenen Basen, falls $b_{1}^{n}=b_{2}^{n}$
weiteres Beispiel f√ºr Zifferncodierung: Darstellung von Zahlen im Flie√ütext

Nachteil: viel gr√∂√üerer Speicherumfang; oder mit bestimmter Anzahl bit l√§sst sich ein viel kleinerer Wertebereich darstellen als bei bin√§r codierten Zahlen
	Bsp.: 
		8bit in Textcodierung: Zahlen von 0 bis 9
		8bit Bin√§rcodierung: Zahlen von 0 bis 255
Besser: BCD (Binary Coded Decimals)
‚Üí 4bit je Dezimalziffer reichen aus
<font style="color:grey">Bsp: Bei ABAP (SAP-Prog.-Sprache) gibt es einen entsprechenden Datentyp sowie zugeh√∂rige Rechenroutinen</font>

| Nr. | 4bit | Dez. Ziff |
| --- | ---- | --------- |
| 0   | 0000 | 0         |
| 1   | 0001 | 1         |
| 2   | 0010 | 2         |
| 3   | 0011 | 3         |
| 4   | 0100 | 4         |
| 5   | 0101 | 5         |
| 6   | 0110 | 6         |
| 7   | 0111 | 7         |
| 8   | 1000 | 8         |
| 9   | 1001 | 9         |
| 10  | 1010 |      <font style="color:indianred">X</font>     |
| 11  | 1011 |           <font style="color:indianred">X</font>|
| 12  | 1100 |           <font style="color:indianred">X</font>|
| 13  | 1101 |           <font style="color:indianred">X</font>|
| 14  | 1110 |           <font style="color:indianred">X</font>|
| 15  |     1111 |           <font style="color:indianred">X</font>|

<font style="color:indianred">X</font> : nicht standardisiert, also entweder "Fehler" oder selbst anderen "wichtigen" Zeichen zugeordnet, z.B. Vorzeichen, Komma, ...

Bsp.: Flie√üband
![[Pasted image 20230207172003.png]]
Falsche Zwischenwerte k√∂nnen immer dann entstehen, wenn zwischen zwei aufeinanderfolgenden Zahlenwerten sich mehr als eine Ziffer (quasi gleichzeitig) √§ndern m√ºsste, die √Ñnderung aber nacheinander vollzogen wird.

---

```ad-info
title:Definition
color:255,130,178
Ein einschrittiger Zahlencode ist eine Form der Zahlencodierung, bei welcher sich zwischen zwei aufeinanderfolgenden Zahlenwerten nur ein Symbol (eine Stelle, eine Ziffer) √§ndert.
```

Bsp.: Der Gray-Code ist ein einschrittiger Code
![[Pasted image 20230207172913.png]]
Bildungsregel:
- Variante *a*: Ausgehend von "$00\dots0$" f√ºr $0$ wird die Symbolfolge f√ºr den n√§chsten Wert gebildet, in dem das rechteste m√∂gliche Symbol ver√§ndert wird, bei welchem eine noch nicht verwendete Symbolfolge entsteht.
- Variante *b*: aus einem $n$-stelligen kann man einen $n+1$-stelligen Gray-Code machen, indem man vor die bisherige Symbolfolge eine $0$ stellt und f√ºr die neuen Symbolfolgen die alten Symbolfolgen in umgekehrter Reihenfolge mit vorangestellter "$1$" verwendet.




---

## Signalcodierung

```ad-info
title:Definition
color:255,130,178
Darstellen von "abstrakten Infos" (typischerweise Bitfolge) als Singal oder Signalfolge.

Ein **Signal** ist eine physisch messbare Gr√∂√üe.

Signalcode ist wichtig f√ºr die Informationsspeicherung im Computer und der Informations√ºbertragung zwischen Computern.
```

*m√∂gliche Signale:*
- <b>mechanisch</b>: Kraft, Beschleunigung, Druck (Hydraulik, Pneumatik)
- <b>optisch</b>: Helligkeit (Amplitude), Farbe (Frequenz)
- <b>elektrisch</b>: bei Aufmodulation auf eine Frequenz: Frequenz, Amplitude, Spannung, Stromst√§rke, elektromagnetische Wellen
- <b>akustisch:</b> Lautst√§rke (Amplitude), Tonh√∂he (Frequenz), Sprache (als komplexe Kombination der beiden vorherig genannten)

*innerhalb des Rechners*: 
- (fast) ausschlie√ülich elektrisch
- zwei Unterarten:
	- kabelgebunden
	- kabellos
	-  <font style="color:grey">Strom und Spannung gehen nur kabelgebunden, bei Aufmodulation auf Tr√§gerfrequenz geht beides</font>
	- im Rechner kann man problemlos Kabel verlegen und auf eine "Tr√§gerfrequenz" verzichten
	 ‚Üí f√ºr uns kommen Strom und Spannung in Frage

![[Pasted image 20230209090008.png]]
$U_{E}\lt U_{S}$, da am Innenwiderstand des Leiters Spannungabf√§lt $U = R \cdot I$ <font style="color:grey">(Beim Spannung Messen flie√üt Strom)</font>
Au√üerdem kann $U_{E}$ durch elektromagnetische Str√∂reinstrahlungen zus√§tzlich verst√§rkt und abgeschw√§cht werden.

![[Pasted image 20230209091056.png]]
$I_{E} = I_{S}$

Die Spannung ist abh√§ngig vom Leitungswiderstand (Entfernung) sowie von eventuellen St√∂reinstralungen; die Stromst√§rke dagegen bleibt immer (nahezu) identisch.

*Aber:* Das Erzeugen einer bestimmten Stromst√§rke erfordert eine Spannung ($U = R\cdot I$). Welche bei gro√üem Widerstand ebenfalls gro√ü sein muss 
‚Üí damit wird viel Energie ben√∂tigt ($P=U\cdot I; \,P=\text{ Leistung } = \frac{\text{Energie}}{\text{Zeit}}$)
‚Üí au√üerdem dann gro√üe W√§rmeentwicklung und dadurch hoher Verschlei√ü der elektrischen Bauteile

*Im Rechner und zwischen Rechnern wird √ºblicherweise Spannung verwendet.*

Zur √úbetragung von Bit ben√∂tigt man (mindestens) zwei Spannungspegel:
<font style="color:grey">(Bsp. f√ºr "single-ended Pegel", bis dann die "0" durch "0V" dargestellt wird)</font>
$$\text{TTL-Pegel}\begin{cases}0\mathrel{\widehat{=}}0V\\1\mathrel{\widehat{=}}5V\end{cases}$$
TTL: Transistor/Transistor-Logic;
"klassisches Pegelpaar", eingef√ºhrt von <i>TexasInstruments</i> um 1960, um interoperabilit√§t zwischen ICs verschiedener Hersteller zu erm√∂glichen.

Unterschied zwischen gr√∂√üeren und kleineren Pegelen ‚Äî Vor- und Nachteile?
- gr√∂√üere Sicherheit bei gr√∂√üeren Pegeln
- weniger Leistung (und damit geringerer Energieverlust) bei kleinern Pegeln
- kleinere Spannungs√§nderungen sind schneller als gr√∂√üere Spannungs√§nderungen zu erreichen
‚Üí Heute eher kleinere Spannungspegel als <i>TTL-Pegel</i> verwendet, aber <i>TTL-Pegel</i> sind der "klassiker" und als Beispiel oft verwendet.

Die Bitfolgen werden als Pegelfolgen dargestellt. Falls f√ºr jedes Bit die gleiche Zeit zur Verf√ºgung steht, handelt es sich um eine "getaktete" √úbertragung.
Der Takt f√ºr die √úbertragung eines Bits hei√üt <font style="color:goldenrod">Taktzeit</font>" oder "<font style="color:goldenrod">Schrittzeit</font>" oder "<font style="color:goldenrod">Periodendauer</font>";
Die Frequenz der Bit√§nderung hei√üt "<font style="color:goldenrod">Taktfrequenz</font>", "<font style="color:goldenrod">Taktrate</font>", "<font style="color:goldenrod">Schrittrate</font>",...

### Signalcodierverfahren:
- Beschreiben die zeitliche Pegelabfolge auf der Leitung f√ºr die **getaktete √úbertragung** einer Bitfolge.

<font style="color:MediumAquaMarine">a) <b><i>T</i></b>akt<b><i>r</i></b>√ºck<b><i>g</i></b>ewinnung (TRG)</font>
<i>TRG</i> ist gegeben, falls die Uhr des Empf√§ngers auf die Uhr des Senders nur w√§hrend des √ºbertragenen Datensignals synchronisiert werden kann.
<b>Grundvoraussetzung f√ºr TRG:</b>
Pegelwechsel zu einem definierten Zeitpunkt

<font style="color:MediumAquaMarine">b) <b><i>G</i></b>leich<b><i>s</i></b>trom<b><i>f</i></b>reiheit (GSF)</font>
Der zeitlich mittlere Pegel auf der Datensignalleitung betr√§gt $0V$.
- Dann kann dieser mittlere Pegel als Masse-Bezugspegel verwendet werden und die Masseleitung eingespart werden.
Grundvoraussetzung in den meisten F√§llen:
	symmetrische Pegel statt <i>Single-ended-Pegel</i>:
	d.h. z.B.: $1=5V$ und $0=-5V$

<font style="color:MediumAquaMarine">c) <b><i>S</i></b>t√∂r<b><i>s</i></b>icher<b><i>h</i></b>eit (SSH)</font>
Unanf√§lligkeit des Verfahrens gegen√ºber Spannungs√§nderungen, welche durch St√∂reinstrahlung von au√üen verursacht werden.
‚Üí SSH ist direkt abh√§ngig von der Anzahl der verwendeten (und zu untescheidenden) Pegel, weil diese zum Vergleich bei allen Verfahren auf den gleichen "maximalen" Pegelhub "verteilt" werden m√ºssen.

<font style="color:MediumAquaMarine">d) <b><i>B</i></b>and<b><i>b</i></b>reiten<b><i>b</i></b>edarf (BBB)</font>
<i>Jeder √úbertragungskanal hat nur eine beschr√§nkte Bandbreite.</i>
$\text{Bandbreite} = \text{obere Grenzfrequenz} - \text{untere Grenzfrequenz}$
Der Einfachkeithalber sei untere Grenzfrequenz = 0Hz
‚Üí dann ist Bandbreite = obere Grenzfrequenz
<b>Nyquist-Theorem:</b>
Wenn mit einer bestimmten Schrittrate Daten √ºbertragen werden sollen, wird mindestens die halbe Schrittrate als Bandbreite auf dem √úbertragungskanal ben√∂tigt. <font style="color:grey">Schrittrate = doppelte Bandbreite</font>


#### 1. Non-Return to Zero (NRZ)
W√§hrend der gesamten Schrittzeit wird der Pegel eingenommen, welcher dem √ºbertragenem Bitwert entspricht.

Neben dem Informationssignal gibt es ein Taktsignal, welches man √ºber eine extra Leitung √ºbertragen kann.
Um diese Leitung einzusparen, muss man sich vorher auf eine Taktrate einigen und w√§hrend der √úbertragung immer wieder eine Synchronisierung der Uhren vornehmen, um ein zu weites Auseinanderlaufen der Uhren zu verhindern.

<font style="color:PaleTurquoise"><b>TRG</b> bei NRZ:</font> Bei jeder "01"-oder "10" Folge im Bitstrom. Bei l√§ngeren Folgen von nur "0" oder nur "1" ist <b>keine</b> TRG m√∂glich.

<font style="color:PaleTurquoise"><b>GSF</b> bei NRZ:</font> bei im Datenstrom gleichverteilten "0" und "1"
	<font style="color:cornflowerblue">Gleichverteilung im Datenstrom?</font>
	z.B. √úbertragung von Texten mit UTF-8 codierte Schriftzeichen:
		die meisten Schriftzeichen sind auch mit ASCII darstellbar, das achte Bit ist "0" ‚Üí <b>keine</b> Gleichverteilung
	z.B. Codierte Zeichen:
		-  Wertebereich wird so gew√§hlt, dass selten gro√üe Werte √ºbertragen werden
		-  h√∂chstwertige Bit seltener "1" als "0" ‚Üí <b>keine</b> Gleichverteilung
	‚Üí bei veschl√ºsselten oder komprimierten Daten kann man im allgemeinen von einer Gleichverteilung ausgehen, bei allen anderen Daten (eher) nicht.
‚Üí eher keine GSF bei NRZ

<font style="color:PaleTurquoise"><b>SSH</b> bei NRZ:</font> Optimal, da "nur" zwei Pegel (weniger geht nicht) unterschieden k√∂nnen werden m√ºssen.

<font style="color:PaleTurquoise"><b>BBB</b> bei NRZ:</font> Auf der Leitung liegt eine Frequenz, welche der halben Schrittrate entspricht, weil die Periodendauer zwei Schrittzeiten entspricht, also optimal (halbe Schrittrate).
![[Pasted image 20230216090511.png|170]]

![[Pasted image 20230209120331.png]]

#### 2. Return-to-Zero (RZ)
Jede Schrittzeit wird in zwei gleichgro√üe H√§lften geteilt. In der ersten H√§lfte wird der Pegel eingenommen, welcher dem √ºbertragenen Bitwert entspricht, in der zweiten H√§lfte immer der 0-Pegel.

<font style="color:PaleTurquoise"><b>TRG</b> bei RZ:</font> Bei jeder "1"; nur bei l√§ngerer Folge von nur "0" gibt es <b>keine</b> TRG.

<font style="color:PaleTurquoise"><b>GSF</b> bei RZ:</font>
- unsinnig:
	- symmetrischer Pegel und nur "1"
	- single-ended-Pegel und nur "0"
- gleichverteilte "0" und "1" und "merkw√ºrdiges" Pegelverh√§ltnis von 3: z.B. $1 \mathrel{\widehat{=}} 15V$ und $0 \mathrel{\widehat{=}} -5V$
‚Üí de facto NIE

<font style="color:PaleTurquoise"><b>TRG</b> bei RZ:</font> Optimal, da "nur" zwei Pegel unterschieden k√∂nnen werden m√ºssen.

<font style="color:PaleTurquoise"><b>BBB</b> bei NRZ:</font> Schlecht, weil doppelt soviel wie mindestens ben√∂tigt.
![[Pasted image 20230216090750.png|170]]

![[Pasted image 20230209103841.png]]

#### 3. Alternate Mark Inversion (AMI)
Verfahren √§hnlich <b>NRZ</b> mit <i>single-ended-Pegeln</i>, aber jede zweite "1" wird mit dem invertierten Pegel der ersten "1" √ºbertragen
‚Üí insgesamt 3 Pegel: $0 \mathrel{\widehat{=}} 0V$, $1\mathrel{\widehat{=}}\text{ abwechselnd } +5V \text{ und } -5V$

<font style="color:PaleTurquoise"><b>TRG</b> bei AMI:</font> Bei jeder "1"; denn bei jeder "1" gibt es sogar zwei definierte Pegelwechsel (n√§mlich zu Beginn und Ende der Schrittzeit).

<font style="color:PaleTurquoise"><b>GSF</b> bei AMI:</font> Nach jeder zweiten "1"; bei einer entsprechend langen √úbertragungsdauer kann der GS-Anteil der ungeraden "1" vernachl√§ssigt werden.
‚Üí praktisch <b>immer</b> GSF

<font style="color:PaleTurquoise"><b>SSH</b> bei AMI:</font> Schlecht, da drei Pegel unterschieden k√∂nnen werden m√ºssen.

<font style="color:PaleTurquoise"><b>BBB</b> bei NRZ:</font> halbe Schrittrate ‚Üí optimal

![[Pasted image 20230209112254.png]]

#### 4. Manchaster-Codierung
Die zu √ºbertragenden Daten werden nicht durch einen bestimmten Pegel, sondern durch eine Pegelwechsel zu einem bestimmten Zeitpunkt (m√ºndlich: in der "Mitte" der Schrittzeit) dargestellt.
z.B. 0-Pegel ‚Üí 1-Pegel $\mathrel{\widehat{=}}$ "1" <font style="color:grey">(steigende Flanke)</font> und 1-Pegel ‚Üí 0-Pegel $\mathrel{\widehat{=}}$ 0 <font style="color:grey">(fallende Flanke)</font>
Gegebenenfalls muss ein zus√§tzlicher Pegelwechsel zu Beginn der Schrittzeit eingef√ºgt werden, dieser steht allerdings <b>nicht</b> f√ºr einen Bitwert.

<font style="color:PaleTurquoise"><b>TRG</b> bei Manchaster:</font>  Immer, da in der Mitte jeder Schrittzeit ein Pegelwechsel stattfindet.

<font style="color:PaleTurquoise"><b>GSF</b> bei Manchaster:</font>  Immer (bei symmetrischen Pegeln), da sich die Pegel der ersten und zweiten Schrittzeit gegenseitig ausgleichen.

<font style="color:PaleTurquoise"><b>SSH</b> bei Manchaster:</font> Optimal, da (nur) zwei verwendete Pegel.

<font style="color:PaleTurquoise"><b>BBB</b> bei NRZ:</font> ganze Schrittrate ‚Üí schlecht (Frequenz wird bei "00...0" oder "11...1" erzeugt)

![[Pasted image 20230209115740.png]]

#### √úbersicht

|                                                           | NRZ                                                                              | RZ                                                                                    | AMI                                                                             | Manchaster                                            |
| --------------------------------------------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ----------------------------------------------------- |
| <b>TRG</b>                                                | <font style="color:red">‚äñ‚äñ</font><br>bei "$10$" oder "$01$" <font style="opacity:0">abcdefghijklmnop</font>                    | <font style="color:red">‚äñ</font><br>bei jeder "$1$" <font style="opacity:0">langeswort</font> | <font style="color:red">‚äñ</font><br>bei jeder "$1$"                             | <font style="color:green">‚äï</font><br>immer           |
| <b>GSF</b><br>(Grundvoraussetzung: symmetrische Pegel)                                            | <font style="color:red">‚äñ</font><br>"$0$" und "$1$" gleichgestellt im Datenstrom | <font style="color:red">‚äñ‚äñ</font><br>de facto nie <font style="opacity:0">abc</font>  | <font style="color:green">‚äï</font><br>nach jeder zweiten "$1$", praktisch immer | <font style="color:green">‚äï‚äï</font><br>immer          |
| <b>SSH</b><br>(abh√§ngig von der Anzahl verwendeter Pegel) | <font style="color:green">‚äï</font><br>2                                          | <font style="color:green">‚äï</font><br>2                                               | <font style="color:red">‚äñ</font><br>3                                           | <font style="color:green">‚äï</font><br>2               |
| <b>BBB</b><br>(in Abh√§ngikeit der Schrittrate)            | <font style="color:green">‚äï</font><br>halbe Schrittrate                          | <font style="color:red">‚äñ</font><br>ganze Schrittrate                                 | <font style="color:green">‚äï</font><br>halbe Schrittrate                         | <font style="color:red">‚äñ</font><br>ganze Schrittrate |

**praktischer Einsatz:**
[[1. Codierung#4. Manchaster-Codierung|Manchaster]]: gut f√ºr Netzwerkschnittstellen, z.B. bei Ethernet eingesetzt (Leitungseinsparung bei TRG und GSF spart Geld, SSH auf l√§ngeren Strecken ebenfalls wichtig)

[[1. Codierung#1. Non-Return to Zero (NRZ)|NRZ]]: gut f√ºr "interne Schnittstellen", z.B. zwischen ICs oder verschiedenen Bauteilen (Masse- und Taktleitung k√∂nnen problemlos an jedes IC gef√ºhrt werden)

**TRG** ist bei heutigen modernen, schnellen, bit-seriellen Schnittstellen (PCI-Express, S-ATA)
‚Üí Verfahren zwischen TRG, falss das Signalcodierverfahren (z.B. NRZ) von sich aus keine TRG () erm√∂glicht

1. *Startbitsequenz*
	Vor eine feste L√§nge von $n$ Nutzdatenbit wird eine Bitsequenz gestellt, die sichere TRG erm√∂glicht.
	z.B. bei [[1. Codierung#1. Non-Return to Zero (NRZ)|NRZ]]: "10" oder "01"
	z.B. bei [[1. Codierung#2. Return-to-Zero (RZ)|RZ]]: eine "1" als Startbit (keine "Sequenz")
	<font style="color:green">‚äï</font> extrem einfaches Verfahren
	<font style="color:red">‚äñ</font> gro√üer, konstanter Overhead, d.h. <b>Nutzdatenrate</b> ist immer <b>kleiner</b> als die <b>Schrittrate</b>
2. *Bitstopfen / Bit Stuffing*
	Nach $n$ gleichen Bitwerten im Nutzdatenstrom wird ein dazu <b>inverses Bit</b> als "Stopfbit" in den √ºbertragenen <b>Datenstrom</b> eingef√ºgt.
	<i>Bitstopfen</i> bei $n = 3$:
	$0\;\,0\;\,1\;\,0\;\,1\;\,1\;\,1\;{\color{red}|}\;\,1\;\,0\;\,0\;\,0\;{\color{red}|}\;\,1\;\,1\;\,1\;{\color{red}|}\;\,0$   Nutzdatenstrom
	$1.\,2.\,1.\,1.\,1.\,2.\,3.{\color{red}|}\;1.\,1.\,2.\,3.\,{\color{red}|}\;1.\,2.\,3.\,{\color{red}|}\,1.$  Z√§hler
	$\qquad\qquad\qquad\;{\color{red}‚Üë}\qquad\quad\;\;\;{\color{red}‚Üë}\qquad\;\;\;{\color{red}‚Üë}\;\,$
	$\qquad\qquad\qquad\;0\qquad\quad\;\;\;1\qquad\;\;\;0\;\,$    Stopfbits 
	Der Empf√§nger muss die eingestopften Bit wieder entfernen, bevor der Nutzdatenstrom "nach oben" gegeben wird.
	<font style="color:green">‚äï</font> deutlich kleinerer Overhead und auch nur dann wenn n√∂tig
	<font style="color:red">‚äñ</font> komplexes und dadruch teures, fehleranf√§lliges Verfahren
	<font style="color:red">‚äñ</font> Nutzdatenrate ist variabel und nicht konstant.
	Einsatz z.B. bei Ethernet (nicht f√ºr TRG, aber im Bitmuster des "Frame Delimiters" im √ºbertragenen Datenstrom auszuschlie√üen)
3. *Blockcodierung*
	Umcodierung eines $n$-bit-Nutzdatenblocks in einem ($n+i$) bit langen zu √ºbertragenden Bitblock. Aus den $2^{n+i}$ m√∂glichen Bl√∂cken werden die $2^{n}$ Bl√∂cke ausgesucht, welche die Anforderung (hier TRG) "am besten" erf√ºllen.
	z.B. $3$B/$4$B-Blockcodierung; also Umsetzung eines $3$-bit-Nutzdatenblocks in einen $4$-bit-Block:
	![[Pasted image 20230216105019.png| center | 300]]
<font style="color:green">‚äï</font> sehr einfaches Verfahren (Realsisierung √ºber Tabelle)
<font style="color:green">‚äï</font> bessere <b>TRG</b> als bei Startbitsequenz (n√§mlich hier z.B. zweimal in jeder Bitfolge)
<font style="color:green">‚äï</font> eventuell auch Gleichstrom-Armut (wenn auch nicht perfekte <b>GSF</b>)
<font style="color:red">‚äñ</font> konstanter hoher Overhead (unabh√§ngig von dessen "Notwendigkeit")

Wahl des Parameters $n$ als Anzahl Schritte ohne <b>TRG</b>
![[Pasted image 20230216105511.png| center | 300]]
Im besten Fall misst der Empf√§nger (bei <i>NRZ</i>) den Pegel in der Mitte der angenommenen Schrittzeit, weil da der Abstand zur vorigen und n√§chsten Schrittzeit am gr√∂√üten ist.
Insgesamt d√ºrfen (√ºber mehrere Schritte) die Uhren von Sender und Empf√§nger maximal eine halbe Schrittzeit voneinander abweichen.
‚Üí F√ºr jede einzelne Uhr ist nur eine Abweichung von einem Viertel (also 25%) erlaubt.
Bei einer vom Uhrenhersteller spezifizierten Gangungenauigkeit von z.B. 5% w√§ren nach 5 Schritten die 25% erreicht ‚Üí $n<5$ (z.B. $n=4$)


